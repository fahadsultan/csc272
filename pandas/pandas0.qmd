
# VECTORIZED OPERATIONS

Vector based programming (also known as array based programming) is a programming paradigm that uses operations on arrays to execute tasks. This is in contrast to scalar based programming where operations are performed on individual elements of an array.

<center>
<img style="filter:invert(1)" width="80%" src="https://www.illustratedbytes.com/blog/series_what_is_kinetica/01-vectorize/assets/sequential.gif">  <img width="80%" style="filter:invert(1)" src="https://www.illustratedbytes.com/blog/series_what_is_kinetica/01-vectorize/assets/vectorize-2.gif">
</center>

Vectorization operates at the level of individual instructions sent to a processor within each node. For instance, in the illustration shown here, the instruction is to add 5 to a column of numbers and copy the results to a new column B. With vectorization, all the data elements in that column are transformed simultaneously, i.e. the instruction to add 5 is applied to multiple pieces of data at the same time. This paradigm is sometimes referred to as Single Instruction Multiple Data (or SIMD).

We can think of vectorization as subdividing the work into smaller chunks that can be handled independently by different computational units at the same time.

<u>In this course, we will be minimizing the use of loops. </u>

| | | 
|:---:|:---:|
|<img src="../assets/serial2.png" alt="fishy" class="bg-primary" width="100%"  style="filter:invert(1)"> |<img src="../assets/vectorized.png" alt="fishy" class="bg-primary" width="40%"  style="filter:invert(1)"> | 
| 1. Serial / Sequential Operations | 2. Vectorized Operations | 

<br/><br/>

This is orders of magnitude faster than the conventional sequential model where each piece of data is handled one after the other in sequence.

Vectorized operations are also known as SIMD (Single Instruction Multiple Data) operations in the context of computer architecture. In contrast, scalar operations are known as SISD (Single Instruction Single Data) operations.

<center>
<img width="60%" src="../assets/simd2.png" style="filter:invert(1)">  
</center>
<br/><br/>

With vectorization, performing the same operation on a modern intel CPU is 16 times faster than the sequential mode. The performance gains on GPUs with thousands of computational cores is even greater. However, despite these remarkable performance benefits, most analytical code out there is written in the slower sequential mode. This is not a surprise, since until about a decade ago, CPU and GPU hardware could not really support vectorization for data analysis. So most implementations had to be sequential.

The last 10 years, however, have seen the rise of new technologies like CUDA from NVidia and advanced vector extensions from Intel that have dramatically shifted our ability to apply vectorization. Because of the power of vectorization, some traditional vendors now make claims about including vectorization in their offerings. But shifting to this new vectorized paradigm is not easy, since all of your code needs to be written from scratch to utilize these capabilities. 

<center>
<img width="100%" src="https://assets.bwbx.io/images/users/iqjWHBFdfxIU/iGGVWf_CDfkE/v2/pidjEfPlU1QWZop3vfGKsrX.ke8XuWirGYh1PKgEw44kE/-1x-1.png" style="filter:invert(1)">  
</center>


<!-- 
<img src="../assets/vectorized3.png" alt="vectorized3" class="bg-primary" width="20%">  -->



Vectorization can only be applied in situations when operations at individual elements are independent of each other. For example, if we want to add two arrays, we can do so by adding each element of the first array to the corresponding element of the second array. This is a vectorized operation. 

<center><img src="../assets/vectorized_sum.png" alt="vectorized2" class="bg-primary" width="30%" style="filter:invert(1)"> </center>

However, for problems such as the Fibonacci sequence, where the value of an element depends on the values of the previous two elements, we cannot vectorize the operation. Similarly, finding minimum or maximum of an array cannot be vectorized.